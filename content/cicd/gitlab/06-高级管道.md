+++
title = '第6章：高级管道：版本控制、缓存、多阶段……'
date = 2024-04-24T14:30:19+08:00
draft = true
+++

当前我们构建的文件中，镜像版本

```yml
variables:
  GIT_DEPTH: 0
  IMAGE_NAME: $CI_REGISTRY_IMAGE
  IMAGE_TAG: "1.2"
  APP_PORT: 3001
```

如果不增加修改，将会一直是1.2，这样做不现实因为会产生覆盖。

生产环境中，每次管道构建都会产生一个新的版本

+ 随着程序改进，我们依然希望保留跟踪版本直接的变化

设置递增版本过程

版本 1.1.1

+ 第一个数字： 程序重大改动，重构，替换编码框架
+ 第二个数字：次要更改，新功能，大的bug修复
+ 第三个数字：补丁版本，小的修改，例如较小的bug修复



在 CI 文件中读取程序的 版本

+ 服务器安装 jq 命令

```sh
[root@monitor ~]# cat p.json   | jq -r '.version'
1.0.0
```



```yaml
build_image:
  stage: build
  tags:
    - ec2
    - aws
    - shell
  before_script:
    - export APP_VERSION=$(cat app/package.json | jq -r '.version')
  script:
    - docker build -t $IMAGE_NAME:$APP_VERSION .
```



即使这样，还需每次修改应用程序中的 version



在构建镜像是 为 Image 添加 TAG 【预定义变量】 

==CI_PIPELINE_IID==: 当前管道的项目级 IID

+ 将用作 TAG 版本的一部分

版本：`1.0.0-2378` 版本号-内部版本

或者将 构建 ID 作为第三个数：`1.0.buildID`

```yaml
build_image:
  stage: build
  tags:
    - ec2
    - aws
    - shell
  before_script:
    - export PACKAGE_JSON_VERSION=$(cat app/package.json | jq -r '.version')
    - export VERSION=$PACKAGE_JSON_VERSION.$CI_PIPELINE_IID
  script:
    - docker build -t $IMAGE_NAME:$VERSION .
```

此时的环境变量只能用于 build_image

不希望在每个任务中设置，避免冗余

+ artifacts：artifacts 关键字用于指定在作业运行后应保存的文件和目录。

生成一个变量文件，供其他任务使用

```yml
build_image:
  stage: build
  tags:
    - ec2
    - aws
    - shell
  before_script:
    - export PACKAGE_JSON_VERSION=$(cat app/package.json | jq -r '.version')
    - export VERSION=$PACKAGE_JSON_VERSION.$CI_PIPELINE_IID
    - echo $VERSION > version-file.txt
  script:
    - docker build -t $IMAGE_NAME:$VERSION .
  artifacts:
    paths:
      - version-file.txt
```



**说明：**

阶段的产物下一阶段可以直接使用，但是在同一阶段中的任务

在 GitLab CI/CD 中，你可以使用 `dependencies` 关键字来指定一个作业依赖于哪些其他作业。这样，这个作业就可以使用那些作业的构建工件（artifacts）。默认情况下，一个作业会依赖于同一阶段中所有其他作业以及所有先前阶段中的作业。

然而，你可以使用 `dependencies` 关键字来更改这个行为。例如，你可以让一个作业只依赖于特定的作业，或者让一个作业不依赖于任何其他作业。

这是一个例子：

```yaml
job1:
  stage: build
  script: echo "This is job1" > file1.txt
  artifacts:
    paths:
      - file1.txt

job2:
  stage: test
  script: cat file1.txt
  dependencies:
    - job1
```

在这个例子中，`job2` 依赖于 `job1`，所以它可以使用 `job1` 的构建工件 `file1.txt`。

需要注意的是，`dependencies` 只能指定在当前作业之前的作业。你不能让一个作业依赖于同一阶段中的后续作业或者后续阶段中的任何作业。如果你需要在作业之间共享数据，你可能需要重新组织你的阶段和作业，或者使用其他方法（如使用外部存储）来共享数据。



push_image

```yml
push_image:
  stage: build
  needs:
    - build_image
  dependencies:
    - build_image
  tags:
    - ec2
    - aws
    - shell
  before_script:
    - export VERSION=$(cat version-file.txt)
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker push $IMAGE_NAME:$VERSION
```

如果有 needs 便不需要 dependencies，存在重叠功能

```yml
push_image:
  stage: build
  needs:
    - build_image
  tags:
    - ec2
    - aws
    - shell
  before_script:
    - export VERSION=$(cat version-file.txt)
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker push $IMAGE_NAME:$VERSION
```



如果在后面的阶段不需要 前面阶段的产物

```yml

test-dev:
  stage: deploy
  dependencies: [] # 不要下载先前阶段任何东西
  script:
    - echo "testing"
```

